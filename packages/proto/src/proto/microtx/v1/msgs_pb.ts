// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file microtx/v1/msgs.proto (package microtx.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../cosmos/base/coin";

/**
 * MsgMicrotx A Msg used to send funds from one Althea network wallet to another,
 * via an automated device. Facilitates Liquid Infrastructure by automatically
 * redirecting funds received by Liquid Infrastructure beyond configured amounts to the EVM.
 * SENDER The account sending funds to receiver, must also be the signer of the
 * message
 * RECEIVER The account receiving funds from sender
 * AMOUNTS The tokens and their quantities which should be transferred, these
 * must be Cosmos coins registered as ERC20s, or the Cosmos representation of ERC20s
 *
 * @generated from message microtx.v1.MsgMicrotx
 */
export class MsgMicrotx extends Message<MsgMicrotx> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<MsgMicrotx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.MsgMicrotx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMicrotx {
    return new MsgMicrotx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMicrotx {
    return new MsgMicrotx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMicrotx {
    return new MsgMicrotx().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMicrotx | PlainMessage<MsgMicrotx> | undefined, b: MsgMicrotx | PlainMessage<MsgMicrotx> | undefined): boolean {
    return proto3.util.equals(MsgMicrotx, a, b);
  }
}

/**
 * @generated from message microtx.v1.MsgMicrotxResponse
 */
export class MsgMicrotxResponse extends Message<MsgMicrotxResponse> {
  constructor(data?: PartialMessage<MsgMicrotxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.MsgMicrotxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMicrotxResponse {
    return new MsgMicrotxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMicrotxResponse {
    return new MsgMicrotxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMicrotxResponse {
    return new MsgMicrotxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMicrotxResponse | PlainMessage<MsgMicrotxResponse> | undefined, b: MsgMicrotxResponse | PlainMessage<MsgMicrotxResponse> | undefined): boolean {
    return proto3.util.equals(MsgMicrotxResponse, a, b);
  }
}

/**
 * A type for the block's event log, every successful Microtx must create one of
 * these in the event log
 *
 * @generated from message microtx.v1.EventMicrotx
 */
export class EventMicrotx extends Message<EventMicrotx> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin amounts = 3;
   */
  amounts: Coin[] = [];

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin fee = 4;
   */
  fee: Coin[] = [];

  constructor(data?: PartialMessage<EventMicrotx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.EventMicrotx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amounts", kind: "message", T: Coin, repeated: true },
    { no: 4, name: "fee", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventMicrotx {
    return new EventMicrotx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventMicrotx {
    return new EventMicrotx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventMicrotx {
    return new EventMicrotx().fromJsonString(jsonString, options);
  }

  static equals(a: EventMicrotx | PlainMessage<EventMicrotx> | undefined, b: EventMicrotx | PlainMessage<EventMicrotx> | undefined): boolean {
    return proto3.util.equals(EventMicrotx, a, b);
  }
}

/**
 * A type for the block's event log recording when a Liquid Infrastructure account
 * has a received balance redirected to its registered LiquidInfrastructureNFT
 *
 * @generated from message microtx.v1.EventBalanceRedirect
 */
export class EventBalanceRedirect extends Message<EventBalanceRedirect> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventBalanceRedirect>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.EventBalanceRedirect";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBalanceRedirect {
    return new EventBalanceRedirect().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBalanceRedirect {
    return new EventBalanceRedirect().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBalanceRedirect {
    return new EventBalanceRedirect().fromJsonString(jsonString, options);
  }

  static equals(a: EventBalanceRedirect | PlainMessage<EventBalanceRedirect> | undefined, b: EventBalanceRedirect | PlainMessage<EventBalanceRedirect> | undefined): boolean {
    return proto3.util.equals(EventBalanceRedirect, a, b);
  }
}

/**
 * Records critical information about a Liquid Infrastructure Account
 * ACCOUNT The bech32 address of the liquid infrastructure account
 * OWNER The bech32 address of the account now in control of the liquid infrastructure
 * NFT_ADDRESS The EVM address of the token contract in control of the liquid infrastructure account's accrued profits
 *
 * @generated from message microtx.v1.LiquidInfrastructureAccount
 */
export class LiquidInfrastructureAccount extends Message<LiquidInfrastructureAccount> {
  /**
   * @generated from field: string owner = 1;
   */
  owner = "";

  /**
   * @generated from field: string account = 2;
   */
  account = "";

  /**
   * @generated from field: string nft_address = 3;
   */
  nftAddress = "";

  constructor(data?: PartialMessage<LiquidInfrastructureAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.LiquidInfrastructureAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "nft_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiquidInfrastructureAccount {
    return new LiquidInfrastructureAccount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiquidInfrastructureAccount {
    return new LiquidInfrastructureAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiquidInfrastructureAccount {
    return new LiquidInfrastructureAccount().fromJsonString(jsonString, options);
  }

  static equals(a: LiquidInfrastructureAccount | PlainMessage<LiquidInfrastructureAccount> | undefined, b: LiquidInfrastructureAccount | PlainMessage<LiquidInfrastructureAccount> | undefined): boolean {
    return proto3.util.equals(LiquidInfrastructureAccount, a, b);
  }
}

/**
 * MsgLiquify Converts the sender's account into a piece of Liquid Infrastructure,
 * by creating a Non-fungible Token (NFT) within the Althea L1 EVM which will control all balances
 * held by the Liquid Infrastructure Account (beyond a configurable threshold).
 * The liquid infrastructure account itself will be the initial owner of the NFT,
 * and must transfer control through the EVM NFT contract
 * SENDER The bech32 address of the account to liquify, must also be the signer of the message
 *
 * @generated from message microtx.v1.MsgLiquify
 */
export class MsgLiquify extends Message<MsgLiquify> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  constructor(data?: PartialMessage<MsgLiquify>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.MsgLiquify";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgLiquify {
    return new MsgLiquify().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgLiquify {
    return new MsgLiquify().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgLiquify {
    return new MsgLiquify().fromJsonString(jsonString, options);
  }

  static equals(a: MsgLiquify | PlainMessage<MsgLiquify> | undefined, b: MsgLiquify | PlainMessage<MsgLiquify> | undefined): boolean {
    return proto3.util.equals(MsgLiquify, a, b);
  }
}

/**
 * MsgLiquifyResponse potentially returns useful information from the liquification of an account
 *
 * @generated from message microtx.v1.MsgLiquifyResponse
 */
export class MsgLiquifyResponse extends Message<MsgLiquifyResponse> {
  /**
   * @generated from field: microtx.v1.LiquidInfrastructureAccount account = 1;
   */
  account?: LiquidInfrastructureAccount;

  constructor(data?: PartialMessage<MsgLiquifyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.MsgLiquifyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: LiquidInfrastructureAccount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgLiquifyResponse {
    return new MsgLiquifyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgLiquifyResponse {
    return new MsgLiquifyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgLiquifyResponse {
    return new MsgLiquifyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgLiquifyResponse | PlainMessage<MsgLiquifyResponse> | undefined, b: MsgLiquifyResponse | PlainMessage<MsgLiquifyResponse> | undefined): boolean {
    return proto3.util.equals(MsgLiquifyResponse, a, b);
  }
}

/**
 * A type for the block's event log, every successful MsgLiquify must create one of
 * these in the event log
 *
 * @generated from message microtx.v1.EventAccountLiquified
 */
export class EventAccountLiquified extends Message<EventAccountLiquified> {
  /**
   * @generated from field: string owned = 1;
   */
  owned = "";

  /**
   * @generated from field: string nft_address = 2;
   */
  nftAddress = "";

  constructor(data?: PartialMessage<EventAccountLiquified>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "microtx.v1.EventAccountLiquified";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owned", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nft_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAccountLiquified {
    return new EventAccountLiquified().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAccountLiquified {
    return new EventAccountLiquified().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAccountLiquified {
    return new EventAccountLiquified().fromJsonString(jsonString, options);
  }

  static equals(a: EventAccountLiquified | PlainMessage<EventAccountLiquified> | undefined, b: EventAccountLiquified | PlainMessage<EventAccountLiquified> | undefined): boolean {
    return proto3.util.equals(EventAccountLiquified, a, b);
  }
}
